\documentclass{beamer}
\usetheme{Singapore}
\usecolortheme{default}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{verbatim}
\usepackage{graphics}
\usepackage{listings}
\usepackage{lmodern}

\title{Understanding Git with Alloy}
\subtitle{Milestone 3}
\author{Cláudio Lourenço \and Renato Neves}
\institute{University of Minho\\
Formal Methods in Software Engineering}


\logo{ \includegraphics[width=0.15\textwidth]{images/csail_logo.png}
       \includegraphics[width=0.15\textwidth]{images/uminho_eng_logo.png}}

\begin{document}

\frame {
   \titlepage
}

\frame{
   \frametitle{Table of contents}
   \tableofcontents 
}

\section{Git as VCS}

\begin{frame}
	\frametitle{Git as VCS}
	\begin{block}{Git is one of many Version Control Systems}
		\begin{itemize}
		\item Fast
		\item Efficient
		\item Oriented to snapshots, not differences
		\item Widely used
	\end{itemize}
	\end{block}
\end{frame}

\section{Project motivation and objectives}
\begin{frame}
	\frametitle{Motivation for this project}
	\begin{block}{Gap in the understanding of Git}
		\begin{itemize}
		\item Lack of precise descriptions
		\item Contradictions in some manuals
		\end{itemize}
	\end{block}
	\begin{block}{An opportunity  appears}
	\begin{itemize}
	\item Developers could benefit from a manual
		that is precise and rigorous
	\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{The dark world of Git}
	\begin{block}{The common (and above average) knowledge of Git }
	\begin{itemize}
	\item "if there are any uncommitted changes when you run git checkout,
	 Git will behave very strangely." \footnote{"Understanding Git" Manual}
	\item "When you create a branch, it will contain everything
         committed on the branch you created it from at that given
         point. So if you commit more things on the master branch like
         you have done (after creating b), then switch to branch b,
         they won't appear. This is the correct behavior. Does that
         answer your question?" \footnote{An user of Git development 
	 mailing list} 
	\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Objectives of this project}
	\begin{block}{Shine some light in Git internals}
		\begin{itemize}
			\item Build a precise model of how Git works, using 
			Alloy
			\item Analyze the model and verify which properties
			does (not) guarantee
			\item Help others understand Git, building
			a manual with public access
		\end{itemize}
	\end{block}
\end{frame}


\section{Git internals}

\begin{frame}
   \frametitle{The Git Structure}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/git_workflow.png}
   \end{figure}
\end{frame}

\begin{frame}
   \frametitle{Repository}
   \begin{figure}
      \centering
      \includegraphics[width=0.4\textwidth]{images/workflow2.png}
   \end{figure}
\end{frame}

\begin{frame}
\frametitle{Repository}
   \begin{figure}
      \centering
      \includegraphics[width=0.5\textwidth]{images/legenda2.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Blob and Tree}
   \begin{block}{Blob}
      \begin{itemize}
         \item Represents the content of a file
         \item The identifier is calculated from its content, thus files with
	 same content will share the same blob
      \end{itemize}
      \tiny
      \color{blue}
      \begin{lstlisting}
      sig Blob extends Object {}
      \end{lstlisting}
   \end{block}
   \begin{block}{Tree}
      \begin{itemize}
         \item Contains Blobs or other Trees 
         \item Used to represent the file system structure
	 \item The identifier is calculated in a similar way to the Blobs. Thus, 
	 for Trees sharing also exists
      \end{itemize}
      \tiny
      \color{blue}
      \begin{lstlisting}
      sig Tree extends Object {
         
         contains: Name -> lone(Tree+Blob)
      
      }
      \end{lstlisting}
   \end{block}
\end{frame}




\begin{frame}[fragile]
   \frametitle{Commit}
   \begin{itemize}
      	\item A snapshot of the project on a certain moment
      in time
      	\item Has a set of parents, that are considered the previous commits 
	\item Points to a Tree that is equivalent to the root folder in the
	working directory
	\item An auxiliar relation named "Abstract" was specified to be easy to
	model the commit operation
   \end{itemize}
   \tiny
   \color{blue}
   \begin{lstlisting}
                        sig Commit extends Object {
                           points : Tree,
                           parent : set Commit,
                           abs: Path -> Object,
                           merge : set State
                        }
                           
                        sig RootCommit extends Commit {}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Branch and HEAD}
   \begin{block}{Branch}
      \begin{itemize}
         \item Pointer to a commit, unlike other VCS where a branch is a full
	 copy of the repository
      \end{itemize}
   \end{block}
   \begin{block}{HEAD}
      \begin{itemize} 
         \item Special reference that identifies the current Branch
      \end{itemize}
   \end{block}
   \tiny
   \color{blue}
   \begin{lstlisting}
                        sig Branch{
                           marks: Commit lone -> State,
                           branches: set State,
                           head: set State
                        }

                        lone sig Master extends Branch{}
   \end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Repository}
	\begin{figure}
		\centering
		\includegraphics[width=0.4\textwidth]{images/object_assoc.png}
	\end{figure}
\end{frame}

\begin{frame}
   \frametitle{Working Directory}
   \begin{figure}
      \centering
      \includegraphics[width=0.4\textwidth]{images/workflow3.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Working Directory}
   \begin{itemize}
      	\item Subset of a file system, that is tracked by Git
   	\item Was not modeled in this project
	\item However files were modeled. 
	\item Our convention dictates, if a file exists on an Alloy
	instance, then automatically exists in the Working Directory
   \end{itemize}
   \tiny
   \color{blue}
   \begin{lstlisting}
                        sig Path {
                           pathparent: lone Path,
                           name: Name,
                           unmerge: set State
                        }

                        one sig Root extends Path{}
   \end{lstlisting}
\end{frame}

\begin{frame}
   \frametitle{Index}
   \begin{figure}
      \centering
      \includegraphics[width=0.4\textwidth]{images/workflow1.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Index}
   \begin{itemize}
      \item Contains all files that are going to be committed on the next
      commit 
      \item The index is not necessarily equal to the Working Directory.
      \item If an user wants to commit a new file or a newly modified file,
      first he must add it to the index
   \end{itemize}
   \vspace{10mm}
   \tiny
   \color{blue}
   \begin{lstlisting}
                        sig File{
                           path: Path,
                           blob: Blob,
                           index: set State
                        }

   \end{lstlisting}

\end{frame}


\section{Specification of operations}

\begin{frame}[fragile]
   \frametitle{Modeled Operations}
   \begin{itemize}
      \item Add and Remove
      \item Commit
      \item Branch and Branch Remove
      \item {\bf Checkout}
      \item {\bf Merge (2-way and fast-forward) }
   \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Add and remove}

	\begin{block}{Add}
	\begin{itemize}
		\item Adds a file to the index
		\item Updates the content of a file
		also in the index
		\item Those changes will be stored in the next commit
	\end{itemize}
	\end{block}

	\begin{block}{Remove}
	\begin{itemize}
		\item Removes a file of the index, and from the
		Working Directory (if it's still there)
		\item In the next commmit the file deleted will not appear
	\end{itemize}
	\end{block}

\end{frame}

\begin{frame}[fragile]
   \frametitle{Add}
   \begin{figure}
      \centering
      \includegraphics[width=0.3\textwidth]{images/add1.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Remove}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/remove1.png}
   \end{figure}
\end{frame}

\begin{frame}
	\frametitle{Commit}

	\begin{block}{Commit}
	\begin{itemize}
	\item A snapshot of a project on a certain moment in time
	\item In the first version of the model it was 
	getting almost impossible to specify the operation
	\item The latest version included a relation that associated
	the objects in a commit with the correspondent paths
	\end{itemize}
	\end{block}

\end{frame}

\begin{frame}[fragile]
   \frametitle{Commit}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/commit1.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{Commit}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/commit2.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Checkout}
	\begin{block}{The most difficult operation to specify}
	\begin{itemize}
		\item No manual was found that 
		fully described checkout
		\item Expected pre-conditions were not found. Founding instead
		weaker pre conditions
		\item Strange behaviour caught. Discussed about it 
		with the Git mailing list. Concluded that was a bug
	\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Checkout pre-conditions}
	\begin{block}{Pre condition expected}
	\begin{itemize}
		\item No uncommitted files
	\end{itemize}
	\end{block}
	\begin{block}{Pre conditions found}
	\begin{itemize}
		\item Everything that is in the index has to be
		in the current commit with the same content, except if
		\begin{itemize}
		\item The content of a file is the same in the current
		and destination commit (warning is thrown)
		\item Exists a file in the index, and that file doest not
		exist neither in the current nor in the destination commit
		(warning is thrown)
		\item Content of the file in the index is the same as in the
		destination commit (no warning is thrown)
		\end{itemize}
	\end{itemize}
	\end{block}
\end{frame}
\begin{frame}[fragile]
   \frametitle{Checkout}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/checkout.png}
   \end{figure}
\end{frame}

\begin{frame}
	\frametitle{Merge - The last operation modeled}
	\begin{block}{Merge}
	\begin{itemize}
	\item The current commit and the commit pointed by the specified branch
	will, be merged into a possibly a new commit
	\end{itemize}
	\end{block}
	\begin{block}{Merge types}
	\begin{itemize}
		\item The commit pointed by the branch, is more recent then
		the current, thus the newest commit will take always precedence
		\item The typical 2-way merge, that will create a new commit
		resulting from both commits specified
		\item The 3-way merge, that will also create a new merge commit.
		However this type has much less potential for merge conflicts
		then the last type
	\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
   \frametitle{ A fast-forward Merge}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/fastforwardmerge.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{A 2-way Merge}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/merge2way.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
   \frametitle{A 3-way Merge}
   \begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{images/merge2way.png}
   \end{figure}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Merge specification}
	\begin{itemize}
	\item Modeled the 2-way and fast-forward merge
	\item Not enough time for 3-way, however there is a semi-tested
	version
	\item Created two new relations
	\begin{itemize}
		\item Which files are unmerged
		\item Which commits are going to be parents in the next commit
	\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Merge specification}
	\begin{block}{Most important pre-conditions specified}
	\begin{itemize}
		\item The current commit cannot be more recent than the commit
		pointed by the branch specified
		\item There cannot be an unfinished merge
		\item When it's a fast-forward case, the index cannot have
		uncommitted files that would conflict with files from the 
		resulting merge
		\item When it's a 2-way or 3-way merge, it is not possible
		to exist uncommitted files in the index
	\end{itemize}
	\end{block}


\end{frame}

\section{Documentation}

\begin{frame}
	\frametitle{Website}
	\begin{itemize}
	\item A manual was created using the knowledge obtained
	\item Website was created based on the manual 
	\item Also, all project documentation was put available
	\item \url{http://nevrenato.github.com/CSAIL\_Git}
	\end{itemize}

\end{frame}

\section{Conclusion}

\begin{frame}
	\frametitle{Future Work}
	\begin{itemize}
	\item Model more operations (rebase, fetch, 3-way merge...) 
	\item Specify more properties that the model does (not) guarantee
	\item Build interactive diagrams of concrete examples of operations 
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Conclusions}
	\begin{itemize}
	\item Not near enough time to specify all Git operations
	\item It would be nice to have completeness in the model verification
	\item Model stable and documented 
	enough to be extended with other operations by outsiders
	\item Manuals are difficult to do
	\end{itemize}
\end{frame}


\end{document}
