\section{Git operations}

\subsection{Add and Remove}

When you use the 'git add <file>' command, a file will be
added to the index. The file added can be a new file, or 
a file already existing in the index. When the latter is true, 
git just updates the content of that file. \par
When you add a file, it will be marked to be committed in the next
commit. 
\begin{figure}[h!] 
	\caption{Before the add}
	\centering
	\includegraphics[scale=0.65]{images/add1.png}
\end{figure}

\begin{figure}[h!] 
	\caption{After the add}
	\centering
	\includegraphics[scale=0.65]{images/add2.png}
\end{figure}

\pagebreak

'git rm <file>' can be seen as the inverse operation of the 'git add <file>'.
In this case Git, will remove a file from the index, so it won't appear in the
next commit. Besides being removed from index, it will also be removed from the 
working directory (if it's still there). \par
However, there are a few cases that Git prevents you from removing a file : 
\begin{itemize}
\item The file must exist in the index.
\item Removing a file, when the file with it's current content 
doesn't exist in some commit object.
\end{itemize}
The last restriction exists, to avoid the accidental deletion of files. Imagine the
case where you have a file 'x' with 10k lines of code. You add it to the index,
but, before committing you accidentally use 'git rm x'. Because Git erases from
the index and the working directory you would lose it permanently.

%\subsection{Add and Remove operation properties}
%
%\begin{itemize}
%	\item Adding a file after adding the same file, has no effect
%	\item Adding a file, committing, removing the same file and 
%	committing brings to a commit equal to before of adding the file
%	\item Removing a file and then adding the same file brings to an
%	index equal to the one before removing the file
%\end{itemize}

\subsection{Commit}

The 'git commit' operation, stores the current content of the index in a new
commit. \par
The only restriction that Git has about this operations 
it's that your new commit must have something different from the previous
commit, or, if it's the first commit, then there must exist some content in
current index. \par
When the first commit is created, a branch called "Master" will be created
and will be marked as the current branch. Also, the first commit of a repository
is called a RootCommit. \par

\subsection{Branch}

Git branch operation has several forms, that to different things on git.
The ones which we care are the forms that create and delete branches. \par
When a new branch is created it will point to the current HEAD by default.
\par


The man git-branch says that when deleting a branch, it must be fully
merged in its upstream branch, or in HEAD if no upstream was set. \par

\subsection{Branch operations properties }


\subsection{Checkout}

From man git-checkout : "Switches branches by updating the index, 
working tree, and HEAD to reflect the specified branch or commit". \par

\subsection{Merge}

When you do a 'git merge <branch>', a merge will happen between the current
branch and the branch selected on the command. \par
There can be three types of merge : 
\begin{itemize}
\item A fast-forward merge, that will happen when 
the current commit from the other
branch, is more recent than the current commit from the current branch.
\item A 2-way merge, that happens when the conditions for a fast-forward
don't exist, and there isn't a common ancestor for both commits.
\item A 3-way merge, that happens when the conditions for a fast-forward
don't exist, but, there is a common ancestor for both commits.
\end{itemize}
Besides theses 3 types of merge operation, if a merge has no conflicts then
it will made automatically by Git, otherwise Git will merge as most possible,
and leave the rest to the user. When the user, finishes the merging of files, he
can commit the resulting merge, in a merge commit. \par
While there are unmerged files in the index, you can't commit.
