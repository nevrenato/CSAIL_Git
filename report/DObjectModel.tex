\section {Modelling Git Dynamic Object Model}
The static object model, only by itself, 
is not very useful. And so
the model would be much more interesting if we specify 
the most important git operations. That said in this
section we will focus on modelling the most important
and critical of them. \par

In order to understand them, the definition
of the git Working Directory and git Index is in debt,
but first we give a small the notion of branch.

\subsection{Introducing branches}
Definition of branch: "A branch in Git is {\bf simply a 
lightweight movable pointer to one of these commits}." \cite{progit} 
(pag 39)\\

\begin{lstlisting}
sig Branch{
   on: Commit
}
\end{lstlisting}

A branch in git, is a pointer for a commit. We are always 
working on a certain branch, and all the commits made on 
that branch are independent from the others branch until we 
make a merge. A new branch can be created using 
\emph{git branch branch\_name}. The special pointer called Header 
points to the branch we are working on. \cite{progit} (pag 40)

\begin{lstlisting}
one sig Head{
   current: Branch
}
\end{lstlisting}

We can navigate by different branches using 
\emph{git checkout branch\_name}.\\



Trying to understand branches using git:
\begin{itemize}
   \item if we modify a tracked file, we cannot change branch if we do not add that file to the index and commit it;
%   \item if we add a tracked and modified file to the index and we change branch, that file will be presented on the working directory;
   \item if we create a new file on a branch and then we change branch (without adding the file to the index) that file will be present;
   \item if we create a new file, add it to the index, change branch, commit, go back to the other branch, that file will not be visible;
   \item master branch can be deleted;
\end{itemize}

We can conclude that the index is not connected to a branch. It is something is common to all branches.



------------------------------------
\subsection{Working Directory}
The definition of Working Directory comes as follows:
"The Git 'working directory' is the directory that holds 
the current checkout of the files you are working on.".\\

The working directory is basically what we see in our file 
system. When we change to a certain branch, the files from the 
working directory are replaced by the files from the commit 
corresponding to that branch. So, a working directory is 
composed by: last commit + added files - removed files.\\


\subsection{Index}
"The Git index is used as a staging area between your working directory and your repository." \cite{gitComm} (pag 17)\\
"The index is a binary file (generally kept in .git/index) containing a sorted list of path names, each with permissions and the
SHA1 of a blob object" \cite{gitComm} (pag 120)\\
\begin{lstlisting}
sig PathName{}
one sig Index{
   stage: PathName -> one Blob
}
\end{lstlisting}

-----------------------------------------


\subsection{Working Directory and Index}
The definition of Working Directory comes as follows:
"... simply a {\bf temporary checkout place} where you can 
modify the files {\bf until your next commit}."
\cite{gitComm} (pag 17). \par
So,
the Working Directory, does nothing more than telling
us wich files have been modified since the last commit.

\begin{lstlisting}
sig WorkingD {
	contents : set File
}
\end{lstlisting}

\begin{lstlisting}
abstract sig Type {}
one sig Mod,Add,Del extends Type {}

sig File{
	diff : some Type	
}
\end{lstlisting}

To complement the definition above, git will only
track files that existed in the last commit, thus
new ones will not appear in this directory. \par 
That said, in the Working Directory can only appear
modified ou deleted files. \par

\begin{lstlisting}
fact {

 not Add in (WorkingD.contents).diff
}
\end{lstlisting}

Now for the definition of Index:
"...staging area between your working directory and your
repository. You can use the index to {\bf build up a set of 
changes that you want to commit together}. When you create
a commit, {\bf what is committed is what is currently in the
index, not what is in your working directory.}"
\cite{gitComm} (page 17). So, the Index simply refers the files
that will be commited.

\begin{lstlisting}
sig Index {
	toCommit : set File
}
\end{lstlisting}

What is the pratical difference between the Index and the Working
Directory? The simple answer is that there can be cases when we don't want
to commit something, previously changed.

\subsubsection{The git add command}

This command is one of the most used in git. \cite{gitComm} (page 26)
tells us that
"git add is {\bf used both for new and newly modified files},
and in both cases it takes a snapshot of the given files
and {\bf stages that content in the index, ready for inclusion
in the next commit}." \par 
As already said above a newly modified file, it's tracked by
the Working Directory, so all references to modified files in
the Index must also appear in the Working Directory. For newly
added files that is not the case.
\begin{lstlisting}
pred add [s,s' : State, f : File] {
  
    f.diff in (Add+Mod) 
    s'.workD = s.workD
    s'.index.toCommit = s.index.toCommit + f 
    (s'.index.toCommit).Mod in (s'.workD.contents).Mod
}

\end{lstlisting}

\begin{lstlisting}
sig State {
  workD : WorkingD,
  index : Index
}
\end{lstlisting}

\subsubsection{The git rm command}

This one is generally less used. It's usefullness can be
seen in the following : \cite{progit}
(page 21) says "To remove a file from Git, you have to remove it
from your tracked files (more accurately, {\bf remove it from your
staging area}) and them commit. The {\bf git rm command does that
and also removes the file from your working directory}...". \par
Note that the working directory refered in the citation is not
the git Working Directory, it's the directory of the filesystem itself.
In other words a 'rm <file>' is present inside the 'git rm <file>'. \par
When using git rm
that modification will only appear in the Index. Unless, before
the git rm we delete the file from the filesystem (e.g. rm ). \par

