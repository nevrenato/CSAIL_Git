\section{Git Static Object Model}

In this section we will show the specification in Alloy of the
git object model. This will be mostly based on the textual
specification present in \cite{gitComm}. \par
Thus, we will divide this section in conditions that are specified 
in \cite{gitComm} and conditions that we didn't found explicity
in the book but that are needed for the proper functioning of
git.

\subsection{Explicit specifications}

"All the information needed to represent the history
of a project is stored in files referenced by a 
40-digit {\bf "object name"}..." (page 7)

\begin{lstlisting}
sig Sha{}
\end{lstlisting}

"...and there are four different types of objects: "blob",
"tree", "commit", and "tag". " (page 7)

\begin{lstlisting}
abstract sig Object {
	namedBy : Sha
}
sig Blob extends Object{}
sig Tree extends Object {}
sig Commit extends Object{}
sig Tag extends Object{}
\end{lstlisting}

"A "tree" is basically like a directory - {\bf it references a bunch
of other trees and/or blobs}..." (page 8)

\begin{lstlisting}
sig Tree extends Object {
	references : set (Tree+Blob)
}
\end{lstlisting}

"A "commit" {\bf points to a single tree}...." (page 8)

\begin{lstlisting}
sig Commit extends Object{
	points : Tree
}
\end{lstlisting}

"A "tag" is a way to { \bf mark a specific commit}..." (page 8)

\begin{lstlisting}
sig Tag extends Object{
	marks : Commit
}
\end{lstlisting}

As the book \cite{gitComm} says, a "tree" acts
like a directory, so we know that it or it's 
descendants cannot point to themselves.
\begin{lstlisting}
no ^references & iden 
\end{lstlisting}

"...two "trees" have the { \bf same SHA1 name if and only if their
contents (including, recursively, the contents of all subdirectories)
are identical.} " (page 11)

\begin{lstlisting}
all t,t' : Tree | 
   t.namedBy = t'.namedBy <=> t.references = t'.references
\end{lstlisting}

"What that means to us is that is virtually {\bf impossible to find to 
different objects with the same name}". (page 7) \par
However we know that there is an exception. 
There are cases (defined above)
that allow different trees to have same name. 

\begin{lstlisting}
namedBy.~namedBy - (Tree->Tree) in iden
\end{lstlisting}


\subsubsection{Commit structure}

Again from \cite{gitComm}. \par 
"As you can see,a commit is defined by :
... \par
parent(s) : {\bf The SHA1 name of some number of commits which
represent the immediately previous step(s) in the 
history of the project}. The example above has one parent;
merge commits may have more than one. A commit with no 
parents is called a "root" commit, and represents the 
initial revision of a project. {\bf Each project must have at
least one root. A project can also have multiple roots,
though that isn't common (or necessarily a good idea)}". (page 12)

\begin{lstlisting}

sig Commit extends Object{
  points : Tree,
  parent : set Commit
}
some sig RootCommit extends Commit{}
fact {
  no ^parent & iden
  no RootCommit.parent
  Commit in *parent.RootCommit
}

\end{lstlisting}

\subsection{Implicit specifications}

A commit must point only root trees, unless we want
losses of information.
\begin{lstlisting}
no Commit.points & Tree.references    
\end{lstlisting}

In the object model we don't have orphan Blobs. 
\begin{lstlisting}
Blob in Tree.references
\end{lstlisting}

The same for Trees.
\begin{lstlisting}
Tree in Tree.references + Commit.points
\end{lstlisting}

Sha's that don't point to anywhere are useless.
\begin{lstlisting}
Sha in Object.namedBy
\end{lstlisting}

We can't have the same tree shared by commits. Git
doesn't work that way ("it stores a snapshot of what all 
the files in your project looks like..." \cite{gitComm} (page 7)).
\begin{lstlisting}
points.~points in iden 
\end{lstlisting}

A tree has at most one parent. If this is not true, than there 
is inconsistency in the git "filesystem".
\begin{lstlisting}
all t:Tree | lone references.t
\end{lstlisting}

\section{Index}

\subsection{Explicit specifications}

Now for the definition of Index:
"...staging area between your working directory and your
repository. You can use the index to {\bf build up a set of 
changes that you want to commit together}. When you create
a commit, {\bf what is committed is what is currently in the
index, not what is in your working directory.}"
\cite{gitComm} (page 17). \par

"The index is a binary file (generally kept in .git/index) 
{\bf containing a sorted list of path names}, each with permissions and the
SHA1 of a blob object" \cite{gitComm} (pag 120). \par 

\begin{lstlisting}
one sig Index{	
  stage: Sha one -> File
}{
  Index.stage.File in Blob.namedBy
}
\end{lstlisting}

Also : ``The index {\bf contains all the information necessary to generate a single
(uniquely determined) tree object}'' \cite{gitComm} (pag 121). \par
This description tells us that the index saves a snapshot of the system,
not the differences !

What is the practical difference between the Index and the Working
Directory? The Working Directory is just the root folder of a repository,
that we work on. When we want to save something in a commit, we have to explicitly 
tell git to add that to the Index. Once added, it
will be saved in the git database at the next commit. If we don't want to save
something in a commit, we simply don't add it to the Index.



%\subsection{Branches}
%Definition of branch: "A branch in Git is {\bf simply a 
%lightweight movable pointer to one of these commits}." \cite{progit} 
%(pag 39)
%
%\begin{lstlisting}
% sig Branch{
%   on: Commit
% }
%\end{lstlisting}
%
%``The special pointer called Header 
%points to the branch we are working on''. \cite{progit} (pag 40)
%
%\begin{lstlisting}
%  one sig Head{
%   	current: Branch
%  }
%\end{lstlisting}
%
